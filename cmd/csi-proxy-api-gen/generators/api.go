package generators

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"sort"
	"strings"

	"k8s.io/gengo/args"
	conversiongenerator "k8s.io/gengo/examples/conversion-gen/generators/generator"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
	"k8s.io/klog/v2"

	"github.com/kubernetes-csi/csi-proxy/client/apiversion"
)

/*
This file defines a gengo generator to generate all the boilerplate code API
groups and versions need.

See this repo's client/api/README.md for more context.
*/

const (
	// csiProxyRootPath is the CSI-proxy go library's root path.
	csiProxyRootPath = "github.com/kubernetes-csi/csi-proxy"
	// csiProxyAPIPath is the default location for API group definitions.
	csiProxyAPIPath = csiProxyRootPath + "/client/api/"

	// defaultServerBasePkg is the default output location for generated server files.
	defaultServerBasePkg = csiProxyRootPath + "/pkg/server"

	// defaultClientBasePkg is the default output location for generated client files.
	defaultClientBasePkg = csiProxyRootPath + "/client/groups"

	// tagMarker and tagName should be the beginning of comment lines in a group definition's
	// root package's doc.go that hold instructions for this generator.
	// The acceptable values are:
	// * +csi-proxy-api-gen with no value, to indicate that this package is a group definition's
	//		root package
	// * +csi-proxy-api-gen=groupName:<snake_case_group_name> to set the group's name
	//   	- defaults to the package's name
	// * +csi-proxy-api-gen=serverBasePkg:<pkg_path> to set the base output directory
	//		for generated server files - defaults to github.com/kubernetes-csi/csi-proxy/pkg/server
	// * +csi-proxy-api-gen=clientBasePkg:<pkg_path> to set the base output directory
	//		for generated client files - defaults to github.com/kubernetes-csi/csi-proxy/client/groups
	tagMarker = "+"
	tagName   = "csi-proxy-api-gen"

	// headerComment is the comment on the first line of every generated file.
	headerComment = "// Code generated by csi-proxy-api-gen. DO NOT EDIT.\n\n"

	// pkgPlaceholder can be used as a placeholder for the package path, e.g.
	// when deriving what callbacks an API group's internal server must have
	// in order to be able to service all its versions.
	// See also replaceTypesPackage.
	pkgPlaceholder = "__PKG_PLACEHOLDER__"
)

// nameSystems returns the name system used by the generators in this package.
func nameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public":        namer.NewPublicNamer(0),
		"removePackage": &removePackageNamer{},
		"short":         &shortNamer{},
	}
}

// defaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func defaultNameSystem() string {
	return "public"
}

// packages returns a list of package generators.
func packages(context *generator.Context, arguments *args.GeneratorArgs) (pkgs generator.Packages) {
	// find API group definitions
	groups := findAPIGroupDefinitions(context)
	klog.V(5).Infof("Found API groups: %v", groups)

	for _, group := range groups {
		removeGeneratedFiles(group, arguments.OutputBase)
		pkgs = append(pkgs, packagesForGroup(group, arguments.OutputBase)...)
	}
	return
}

// findAPIGroupDefinitions iterates over the context's list of package paths,
// and builds a map mapping API group paths to their definition.
// API group definitions are either:
// * subdirectories of client/api
// * or packages whose doc.go file contains a comment containing relevant tag markers
// If the latter, see the comments on tagMarker and tagName above for supported options.
func findAPIGroupDefinitions(context *generator.Context) []*groupDefinition {
	pkgPaths := context.Inputs

	// first, re-order the inputs by lengths, so that we always process parent packages first
	sort.Slice(pkgPaths, func(i, j int) bool {
		return len(pkgPaths[i]) < len(pkgPaths[j])
	})

	groups := make(map[string]*groupDefinition)

	for _, pkgPath := range pkgPaths {
		klog.V(5).Infof("Considering input %s", pkgPath)

		pkg := context.Universe[pkgPath]
		if pkg == nil {
			// If the input had no Go files, for example.
			continue
		}

		if buildAPIGroupDefinitionFromDocComment(pkgPath, pkg, groups) {
			// found a +csi-proxy-api-gen comment in the package's doc.go file
			continue
		}

		if strings.HasPrefix(pkgPath, csiProxyAPIPath) {
			// part of the canonical API definitions, under client/api
			buildCanonicalAPIGroupDefinition(pkgPath, pkg, groups)
			continue
		}

		// is this package a version of an API group?
		parts := strings.Split(pkgPath, "/")
		parentPkgPath := strings.Join(parts[:len(parts)-1], "/")
		if definition, present := groups[parentPkgPath]; present {
			if !apiversion.IsValidVersion(pkg.Name) {
				klog.Fatalf("Unexpected go package %q, should be of the form \"%s/<version>\", where <version> should be a valid API group version identifier",
					pkg.Name, parentPkgPath)
			}
			klog.V(5).Infof("Found version %q for API group %q", pkg.Name, parts[len(parts)-2])
			definition.addVersion(pkg)
		}
	}

	result := make([]*groupDefinition, len(groups))
	i := 0
	for _, group := range groups {
		// sanity check: every group should have at least one version
		if len(group.versions) == 0 {
			klog.Fatalf("API group %q doesn't have any version", group.name)
		}
		result[i] = group
		i++
	}

	return result
}

// buildAPIGroupDefinitionFromDocComment looks for a +csi-proxy-api-gen comment in the package's
// doc.go file, and if it finds one build the corresponding API definition.
func buildAPIGroupDefinitionFromDocComment(pkgPath string, pkg *types.Package, groups map[string]*groupDefinition) bool {
	commentTags := types.ExtractCommentTags(tagMarker, pkg.Comments)[tagName]

	if len(commentTags) == 0 {
		return false
	}

	definition := newGroupDefinition(pkg.Name, pkg.Path)

	for _, commentTag := range commentTags {
		commentTag = strings.TrimSpace(commentTag)
		if commentTag == "" {
			continue
		}

		parts := strings.Split(commentTag, ":")
		if len(parts) != 2 {
			klog.Fatalf("Malformed comment tag for package %q, should be of the form \"<name>:<value>\", found %q",
				pkgPath, commentTag)
		}
		name := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch name {
		case "groupName":
			definition.name = value
		case "serverBasePkg":
			definition.serverBasePkg = canonicalizePkgPath(value)
		case "clientBasePkg":
			definition.clientBasePkg = canonicalizePkgPath(value)
		default:
			klog.Fatalf("Unknown comment tag %q for package %q", name, pkgPath)
		}
	}

	klog.V(5).Infof("Found API group %q", definition.name)
	groups[pkg.Path] = definition
	return true
}

// buildCanonicalAPIGroupDefinition builds group definitions for API groups under client/api
// Since these API group's directories don't need to contain go files, and as such are not necessarily go packages,
// here we actually directly process versions' packages directly.
func buildCanonicalAPIGroupDefinition(pkgPath string, pkg *types.Package, groups map[string]*groupDefinition) {
	groupNameAndVersion := strings.TrimPrefix(pkgPath, csiProxyAPIPath)
	parts := strings.Split(groupNameAndVersion, "/")

	if len(parts) == 1 {
		// means it's the group's root directory, no need to process it at this time,
		// we'll get around to it when we process its versions' packages
		return
	}

	if len(parts) != 2 || !apiversion.IsValidVersion(parts[1]) {
		klog.Fatalf("Unexpected go package %q, should be of the form \"%s<api_group_name>/<version>\", where <version> should be a valid API group version identifier",
			pkgPath, csiProxyAPIPath)
	}

	groupPath := csiProxyAPIPath + parts[0]
	definition, present := groups[groupPath]
	if !present {
		klog.V(5).Infof("Found API group %q", parts[0])
		definition = newGroupDefinition(parts[0], csiProxyAPIPath+parts[0])
		groups[groupPath] = definition
	}
	definition.addVersion(pkg)

	klog.V(5).Infof("Found version %q for API group %q", parts[1], parts[0])
}

// removeGeneratedFiles removes all generated files before we re-generate them anew.
func removeGeneratedFiles(group *groupDefinition, outputBase string) {
	toRemove := []string{
		path.Join(group.serverPkg(), "api_group_generated.go"),
		path.Join(group.internalServerPkg(), "types_generated.go"),
	}
	for _, version := range group.versions {
		toRemove = append(toRemove,
			path.Join(group.versionedServerPkg(version.Name), "conversion_generated.go"),
			path.Join(group.versionedServerPkg(version.Name), "server_generated.go"),
			path.Join(group.versionedClientPkg(version.Name), "client_generated.go"))
	}

	for _, filePath := range toRemove {
		filePath = path.Join(outputBase, filePath)
		if err := os.RemoveAll(filePath); err != nil {
			klog.Fatalf("unable to remove %q: %v", filePath, err)
		}
		klog.V(5).Infof("Removed generated file %s", filePath)
	}
}

func packagesForGroup(group *groupDefinition, outputBase string) generator.Packages {
	pkgs := generator.Packages{
		&generator.DefaultPackage{
			PackageName: snakeCaseToPackageName(group.name),
			PackagePath: group.serverPkg(),
			HeaderText:  []byte(headerComment),

			GeneratorList: []generator.Generator{
				&apiGroupGeneratedGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "api_group_generated",
					},
					groupDefinition: group,
				},
			},
		},

		&generator.DefaultPackage{
			PackageName: "impl",
			PackagePath: group.internalServerPkg(),
			HeaderText:  []byte(headerComment),

			GeneratorList: []generator.Generator{
				&typesGeneratedGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "types_generated",
					},
					groupDefinition: group,
				},
			},
		},
	}

	// generate a skeleton server.go if it doesn't exist
	if !fileExists(path.Join(outputBase, group.serverPkg(), "server.go")) {
		pkgs = append(pkgs, &generator.DefaultPackage{
			PackageName: snakeCaseToPackageName(group.name),
			PackagePath: group.serverPkg(),

			GeneratorList: []generator.Generator{
				&serverGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "server",
					},
					groupDefinition: group,
				},
			},
		})
	}

	// generate types.go if it doesn't exist and the group only has one version
	if len(group.versions) == 1 && !fileExists(path.Join(outputBase, group.internalServerPkg(), "types.go")) {
		pkgs = append(pkgs, &generator.DefaultPackage{
			PackageName: "impl",
			PackagePath: group.internalServerPkg(),

			GeneratorList: []generator.Generator{
				&typesGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "types",
					},
					groupDefinition: group,
					version:         group.versions[0],
				},
			},
		})
	}

	for _, version := range group.versions {
		// go closures...
		vsn := version
		pkgs = append(pkgs,
			&generator.DefaultPackage{
				PackageName: version.Name,
				PackagePath: group.versionedServerPkg(version.Name),
				HeaderText:  []byte(headerComment),

				GeneratorFunc: func(context *generator.Context) []generator.Generator {
					// this is somewhat of a hack: the conversion generator expects all inputs
					// to be valid go packages - in particular, to have at least one valid go file;
					// which does not hold true for new API versions
					// so here we create a temporary, empty doc.go file that we clean up right after
					docFilePath := path.Join(outputBase, group.versionedServerPkg(vsn.Name), "doc.go")
					if !fileExists(docFilePath) {
						if err := os.MkdirAll(path.Dir(docFilePath), os.ModePerm); err != nil {
							klog.Fatalf("Unable to create directory %q: %v", path.Dir(docFilePath), err)
						}
						contents := fmt.Sprintf("// Temporary code generated by csi-proxy-api-gen. DO NOT COMMIT.\n// Should be removed automatically, but please remove manually otherwise.\n\npackage %s\n", vsn.Name)
						if err := ioutil.WriteFile(docFilePath, []byte(contents), 0644); err != nil {
							klog.Fatalf("Unable to create file %q: %v", docFilePath, err)
						}
						defer func() {
							// best effort here, we just log any errors
							if err := os.RemoveAll(docFilePath); err == nil {
								klog.V(7).Infof("Cleaned up empty doc.go file at %q", docFilePath)
							} else {
								klog.Warningf("Error when trying to remove empty doc.go file %q: %v", docFilePath, err)
							}
						}()
					}

					conversionGenerator, err := conversiongenerator.NewConversionGenerator(context, "conversion_generated", vsn.Path,
						group.versionedServerPkg(vsn.Name), []string{group.internalServerPkg()}, nil)
					if err != nil {
						klog.Fatalf("unable to create conversion generator: %v", err)
					}
					conversionGenerator.
						WithMissingFieldsHandler(func(inVar, outVar conversiongenerator.NamedVariable, member *types.Member, sw *generator.SnippetWriter) error {
							// it is expected for internal and version-specific structs to have different fields
							return nil
						}).
						WithExternalConversionsHandler(func(inVar, outVar conversiongenerator.NamedVariable, sw *generator.SnippetWriter) (bool, error) {
							klog.V(7).Infof("Checking %+v %+v", inVar, outVar)
							if isVersionedVariable(inVar.Type, vsn) || isVersionedVariable(outVar.Type, vsn) {
								// the conversion involves one of the versioned type, so there should
								// be a conversion function defined for this
								line := fmt.Sprintf("if err := %s(*%s, *%s); err != nil {",
									conversiongenerator.ConversionFunctionName(inVar.Type.Elem, outVar.Type.Elem), inVar.Name, outVar.Name)
								sw.Do("$.$\nreturn err\n}\n", line)
								return true, nil
							}
							klog.Warningf("%s require manual conversion to external type %s", inVar.Type, outVar.Type)

							return false, nil
						})

					return []generator.Generator{
						conversionGenerator,
						&serverGeneratedGenerator{
							DefaultGen: generator.DefaultGen{
								OptionalName: "server_generated",
							},
							groupDefinition: group,
							version:         vsn,
						},
					}
				},
			},

			&generator.DefaultPackage{
				PackageName: version.Name,
				PackagePath: group.versionedClientPkg(version.Name),
				HeaderText:  []byte(headerComment),

				GeneratorList: []generator.Generator{
					&clientGeneratedGenerator{
						DefaultGen: generator.DefaultGen{
							OptionalName: "client_generated",
						},
						groupDefinition: group,
						version:         vsn,
					},
				},
			},
		)

		// generate an empty conversion.go file if it doesn't exist
		if !fileExists(path.Join(outputBase, group.versionedServerPkg(vsn.Name), "conversion.go")) {
			pkgs = append(pkgs, &generator.DefaultPackage{
				PackageName: version.Name,
				PackagePath: group.versionedServerPkg(version.Name),

				GeneratorList: []generator.Generator{
					generator.DefaultGen{
						OptionalName: "conversion",
						OptionalBody: []byte("// Add manual conversion functions here to override automatic conversion functions"),
					},
				},
			})
		}
	}

	return pkgs
}

func fileExists(filePath string) bool {
	_, err := os.Stat(filePath)
	if err == nil {
		return true
	}
	if !os.IsNotExist(err) {
		klog.Fatalf("unable to stat file %q: %v", filePath, err)
	}
	return false
}
